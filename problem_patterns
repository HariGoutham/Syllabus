Comprehensive Patterns for LeetCode Problems
Two-Pointer Technique

Used for problems involving arrays and linked lists, especially for finding pairs or subarrays.
Example Problems: 15. 3Sum, 11. Container With Most Water.
Sliding Window Technique

Useful for problems involving contiguous subarrays or substrings, particularly for finding the maximum/minimum or counting elements.
Example Problems: 3. Longest Substring Without Repeating Characters, 76. Minimum Window Substring.
Fast and Slow Pointer

Cycle detection method with O(1) space efficiency, commonly used in linked list problems.
Example Problems: 142. Linked List Cycle II.
Depth-First Search (DFS)

Commonly used in tree and graph traversal problems, as well as for problems that require exploring all possibilities (e.g., backtracking).
Example Problems: 104. Maximum Depth of Binary Tree, 200. Number of Islands.
Breadth-First Search (BFS)

Often applied in shortest path problems in graphs, level-order traversal in trees, and problems requiring exploration of all nodes at the present depth prior to moving on to nodes at the next depth level.
Example Problems: 102. Binary Tree Level Order Traversal, 542. 01 Matrix.
Backtracking

Used for problems involving permutations, combinations, and subsets, as well as constraint satisfaction problems (e.g., N-Queens, Sudoku).
Example Problems: 46. Permutations, 51. N-Queens.
Dynamic Programming (DP)

Key for optimization problems, especially those that can be broken down into overlapping subproblems.
1D DP (e.g., Fibonacci sequence, climbing stairs)
2D DP (e.g., longest common subsequence, knapsack)
DP with Bitmasking (e.g., traveling salesman problem)
Example Problems: 70. Climbing Stairs, 300. Longest Increasing Subsequence.
Greedy Algorithms

Applied in optimization problems where local optimal choices lead to a global optimum (e.g., interval scheduling, coin change).
Example Problems: 455. Assign Cookies, 621. Task Scheduler.
Binary Search

Useful for searching in sorted arrays or for problems that can be transformed into a search space (e.g., finding the smallest or largest element that meets a condition).
Example Problems: 704. Binary Search, 33. Search in Rotated Sorted Array.
Modified Binary Search

Search in variations of binary search problems, such as rotated or specialized arrays.
Example Problems: 33. Search in Rotated Sorted Array.
Topological Sort

Used in problems involving directed acyclic graphs (DAGs), particularly for scheduling tasks or resolving dependencies.
Example Problems: 207. Course Schedule, 210. Course Schedule II.
Bit Manipulation

Useful for problems involving subsets, unique numbers, or when optimizing space and time (e.g., finding the single number in an array).
Example Problems: 136. Single Number, 190. Reverse Bits.
Bitwise XOR

Toggle bits operation, efficient for pairing and finding unique elements.
Example Problems: 136. Single Number.
Mathematical Patterns

Includes techniques for prime number generation (Sieve of Eratosthenes), GCD/LCM calculations, and combinatorial problems.
Example Problems: 204. Count Primes, 29. Divide Two Integers.
String Manipulation Patterns

Commonly used for substring search problems, anagrams, palindromes, and regular expression matching.
Example Problems: 5. Longest Palindromic Substring, 49. Group Anagrams.
Graph Traversal Patterns

Techniques for exploring graphs, including:
Union-Find (for connected components)
Dijkstra's Algorithm (for shortest paths)
Floyd-Warshall (for all pairs shortest paths)
Example Problems: 547. Number of Provinces, 787. Cheapest Flights Within K Stops.
Interval Problems

Patterns for merging intervals, finding overlaps, and scheduling tasks.
Example Problems: 56. Merge Intervals, 57. Insert Interval.
Matrix Traversal Patterns

Techniques for traversing 2D matrices, such as spiral order traversal
